<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DevTools on Xing Yahao</title>
    <link>https://xingyahao.com/categories/devtools/</link>
    <description>Recent content in DevTools on Xing Yahao</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <copyright>© Xing Yahao</copyright>
    <lastBuildDate>Mon, 11 Aug 2025 18:23:00 +0900</lastBuildDate>
    <atom:link href="https://xingyahao.com/categories/devtools/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>kubectl-execrec: Session Recording for kubectl exec for auditing and compliance with security</title>
      <link>https://xingyahao.com/posts/kubectl-execrec-session-recording-for-kubectl-exec-for-auditing-and-compliance-with-security/</link>
      <pubDate>Mon, 11 Aug 2025 18:23:00 +0900</pubDate>
      <guid>https://xingyahao.com/posts/kubectl-execrec-session-recording-for-kubectl-exec-for-auditing-and-compliance-with-security/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://miro.medium.com/v2/resize:fit:700/1*xpNw34UIvHmnt-4OLl-G3Q.png&#34; alt=&#34;intro-image-created-by-chatgpt.png&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34;&gt;&#xA;&lt;/p&gt;&#xA;&lt;h2 id=&#34;why-i-created-this-plugin&#34;&gt;Why I Created This Plugin&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/keidarc/kubectl-execrec&#34;&gt;https://github.com/keidarc/kubectl-execrec&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;Kubernetes has built-in audit logs, but they only capture API calls, not the actual session content. When you use &lt;code&gt;kubectl exec&lt;/code&gt;, you get audit entries showing who accessed which pod, but not what commands were run or what output was produced.&lt;/p&gt;&#xA;&lt;p&gt;For comprehensive security monitoring, tools like &lt;a href=&#34;https://falco.org/&#34;&gt;Falco&lt;/a&gt; provide real-time threat detection across containers and Kubernetes. However, these are heavy solutions designed for enterprise security teams.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Introducing kubectl-eks-viewer Bridge the Gap between kubectl and AWS CLI</title>
      <link>https://xingyahao.com/posts/introducing-kubectl-eks-viewer-bridge-the-gap-between-kubectl-and-aws-cli/</link>
      <pubDate>Sat, 01 Feb 2025 09:21:51 +0900</pubDate>
      <guid>https://xingyahao.com/posts/introducing-kubectl-eks-viewer-bridge-the-gap-between-kubectl-and-aws-cli/</guid>
      <description>&lt;p&gt;As a developer working with Amazon EKS (Elastic Kubernetes Service), I often found myself juggling between different tools like &lt;code&gt;eksctl&lt;/code&gt;, &lt;code&gt;aws-cli&lt;/code&gt;, and &lt;code&gt;kubectl&lt;/code&gt; to manage and view EKS resources. While &lt;code&gt;kubectl&lt;/code&gt; provides a great interface for Kubernetes resources, accessing AWS-specific EKS resources required switching to other tools, breaking the workflow and reducing productivity.&lt;/p&gt;&#xA;&lt;p&gt;The most common task was simply checking the status of EKS-related AWS resources - What are the desired count of my nodegroups? What addons are installed? What pod identity associations exist? Getting this information required multiple commands across different tools. I wanted a single command that could show me everything at once, following the familiar kubectl patterns I use every day.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Introducing E1s the K9s Inspired Cli for Aws Ecs</title>
      <link>https://xingyahao.com/posts/introducing-e1s-the-k9s-inspired-cli-for-aws-ecs/</link>
      <pubDate>Fri, 19 Apr 2024 09:21:51 +0900</pubDate>
      <guid>https://xingyahao.com/posts/introducing-e1s-the-k9s-inspired-cli-for-aws-ecs/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://storage.googleapis.com/zenn-user-upload/84798ff12916-20240531.png&#34; alt=&#34;84798ff12916 20240531&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34;&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;If you&amp;rsquo;re working with AWS ECS like me, no matter whether with Fargate or EC2, managing resources can sometimes be a challenge to using aws-cli. You might look for something that brings the ease of k9s to k8s, thee1s aims to become the tool you&amp;rsquo;ve been waiting for.&#xA;If you&amp;rsquo;re working with AWS ECS, managing resources with aws-cli can sometimes be a challenge, whether you&amp;rsquo;re using Fargate or EC2. For those seeking the ease of k9s for Kubernetes, e1s is the tool you&amp;rsquo;ve been waiting for.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Shortcomings of npm/yarn and reasons for recommending pnpm</title>
      <link>https://xingyahao.com/posts/npm-yarn-pnpm/</link>
      <pubDate>Mon, 10 Jan 2022 11:52:46 +0900</pubDate>
      <guid>https://xingyahao.com/posts/npm-yarn-pnpm/</guid>
      <description>&lt;h2 id=&#34;what-is-pnpm&#34;&gt;What is pnpm?&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://pnpm.io/&#34;&gt;pnpm&lt;/a&gt; According to the official website, pnpm stands for performant npm.&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Fast, disk space efficient package manager&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;So, pnpm is similar to npm/yarn. Currently (December 2021), many major open source projects (&lt;a href=&#34;https://github.com/vuejs/vue-next&#34;&gt;vue&lt;/a&gt;, &lt;a href=&#34;https://github.com/prisma/prisma&#34;&gt;prisma&lt;/a&gt;&amp;hellip;) use pnpm. This article will look at the shortcomings of npm/yarn and how pnpm solved them in detail.&lt;/p&gt;&#xA;&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;&#xA;&lt;p&gt;npm/yarn - Shortcomings&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;The flat node_modules structure allows access to any package that is not referenced.&lt;/li&gt;&#xA;&lt;li&gt;Packages from different projects cannot be shared, resulting in disk space consumption.&lt;/li&gt;&#xA;&lt;li&gt;Installation speed is slow, and there are duplicate installations in node_modules.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;pnpm - Solution&lt;/p&gt;</description>
    </item>
    <item>
      <title>npm/yarn の不足点と pnpm を推す理由(Japanese)</title>
      <link>https://xingyahao.com/posts/npm-yarn-pnpm-ja/</link>
      <pubDate>Mon, 06 Dec 2021 11:46:46 +0900</pubDate>
      <guid>https://xingyahao.com/posts/npm-yarn-pnpm-ja/</guid>
      <description>&lt;h2 id=&#34;pnpmとは&#34;&gt;pnpmとは&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://pnpm.io/&#34;&gt;pnpm&lt;/a&gt; 公式サイトによると、pnpmはperformant npmを表しています。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Fast, disk space efficient package manager&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;なので、pnpmはnpm/yarn同じような存在です。現在（2021年12月）、たくさんメジャーのオープンソースプロジェクト（&lt;a href=&#34;https://github.com/vuejs/vue-next&#34;&gt;vue&lt;/a&gt;、&lt;a href=&#34;https://github.com/prisma/prisma&#34;&gt;prisma&lt;/a&gt;&amp;hellip;）は pnpmを使用しています。本文はnpm/yarnの不足点、とpnpmはどっやって解決したのかついにて詳細を見てみます。&lt;/p&gt;&#xA;&lt;h2 id=&#34;結論&#34;&gt;結論&lt;/h2&gt;&#xA;&lt;p&gt;npm/yarn - 不足点&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;フラットのnode_modules構造は、引用していない任意のパッケージにもアクセスできてしまう。&lt;/li&gt;&#xA;&lt;li&gt;違うプロジェクトのパッケージが共有できなくて、ディスク容量消耗になる。&lt;/li&gt;&#xA;&lt;li&gt;インストールのスピードが遅い、node_modulesに重複のインストールがある。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;pnpm - 解決法&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;シンボリックリンクを用い独自のnode_modules構造を使用して、package.jsonにあるものしかアクセスできない（厳格）。&lt;/li&gt;&#xA;&lt;li&gt;インストールするパッケージはグローバルストアからハードリンクされ、ディスク容量をセーブ（効率的）。&lt;/li&gt;&#xA;&lt;li&gt;上記の対応で、インストールも早くなる（速い）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;厳格、効率的、速いとモノリポサポートも公式サイトから、pnpmの特徴と言われています。ただ、npm8とyarnもモノリポサポートなので、一応不足点だと考えていないです。pnpmのモノリポをサポートは最後で少し話します。&lt;/p&gt;&#xA;&lt;h2 id=&#34;ディスクスペース&#34;&gt;ディスクスペース&lt;/h2&gt;&#xA;&lt;h3 id=&#34;npmyarn---ディスクスペース消耗のnode_modules&#34;&gt;npm/yarn - ディスクスペース消耗のnode_modules&lt;/h3&gt;&#xA;&lt;p&gt;npm/yarnはディスク容量使いすぎという不足点があって、同じパッケージを100回分インストールしたら、100分のパッケージがnode_modulesのディスクに保存されます。日常の例では、前のプロジェクトが終わって、node_modulesがそのまま残ってしまったら、大量のディスク容量を使うことがよくあります。これを解決するため、&lt;a href=&#34;https://npkill.js.org/&#34;&gt;npkill&lt;/a&gt;がよく使われます。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ npx npkill&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;で現在フォルダ配下で全てのnode_modulesをスキャンして、動的で削除できます。&lt;/p&gt;&#xA;&lt;h3 id=&#34;pnpm---効率的なディスクスペース&#34;&gt;pnpm - 効率的なディスクスペース&lt;/h3&gt;&#xA;&lt;p&gt;一方、pnpmはパッケージを同一フォルダ（content-addressable store）に保存して、同じパッケージの同じばジョンを再度インストールしたら、ハードリンクを作るだけです。MacOsデフォルトの場所は~/.pnpm-storeになります。しかも、同じパッケージの違うバージョンは差分だけが新たに保存されます。そうしたら、インストールする時に、storeにあったら、再利用、なければ、ダンロードしてstoreに保存する形になります。&lt;/p&gt;&#xA;&lt;p&gt;ハードリンクを使って、できたことは&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;インストールが非常に高速(&lt;a href=&#34;https://pnpm.io/benchmarks&#34;&gt;ベンチマーク&lt;/a&gt;でyarnの&lt;a href=&#34;https://classic.yarnpkg.com/en/docs/pnp/&#34;&gt;pnpモード&lt;/a&gt;より早い)&lt;/li&gt;&#xA;&lt;li&gt;ディスク容量節約&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;以下はexpressをインストールしたことがあるパソコンで再インストールする時のアウトプットです。ついでに、npm/yarnインストール時のアウトプットも貼っておきます。&lt;/p&gt;&#xA;&lt;p&gt;pnpm&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fe8019&#34;&gt;$&lt;/span&gt; pnpm i express&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Packages: &lt;span style=&#34;color:#fe8019&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#d3869b&#34;&gt;52&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fe8019&#34;&gt;++++++++++++++++++++++++++++++++++++++++++++++++++++&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Progress: resolved &lt;span style=&#34;color:#d3869b&#34;&gt;52&lt;/span&gt;, reused &lt;span style=&#34;color:#d3869b&#34;&gt;52&lt;/span&gt;, downloaded &lt;span style=&#34;color:#d3869b&#34;&gt;0&lt;/span&gt;, added &lt;span style=&#34;color:#d3869b&#34;&gt;0&lt;/span&gt;, done&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;dependencies:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fe8019&#34;&gt;+&lt;/span&gt; express &lt;span style=&#34;color:#d3869b&#34;&gt;4.17&lt;/span&gt;&lt;span style=&#34;color:#fe8019&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#d3869b&#34;&gt;1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;npm&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ npm i express&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;npm WARN npm@1.0.0 No description&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;npm WARN npm@1.0.0 No repository field.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;+ express@4.17.1&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;added 50 packages from 37 contributors and audited 50 packages in 4.309s&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;found 0 vulnerabilities&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;yarn&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
