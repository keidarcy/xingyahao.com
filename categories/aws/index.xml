<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>AWS on Xing Yahao</title>
    <link>https://xingyahao.com/categories/aws/</link>
    <description>Recent content in AWS on Xing Yahao</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <copyright>© Xing Yahao</copyright>
    <lastBuildDate>Mon, 11 Aug 2025 18:23:00 +0900</lastBuildDate>
    <atom:link href="https://xingyahao.com/categories/aws/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>kubectl-execrec: Session Recording for kubectl exec for auditing and compliance with security</title>
      <link>https://xingyahao.com/posts/kubectl-execrec-session-recording-for-kubectl-exec-for-auditing-and-compliance-with-security/</link>
      <pubDate>Mon, 11 Aug 2025 18:23:00 +0900</pubDate>
      <guid>https://xingyahao.com/posts/kubectl-execrec-session-recording-for-kubectl-exec-for-auditing-and-compliance-with-security/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://miro.medium.com/v2/resize:fit:700/1*xpNw34UIvHmnt-4OLl-G3Q.png&#34; alt=&#34;intro-image-created-by-chatgpt.png&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34;&gt;&#xA;&lt;/p&gt;&#xA;&lt;h2 id=&#34;why-i-created-this-plugin&#34;&gt;Why I Created This Plugin&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/keidarc/kubectl-execrec&#34;&gt;https://github.com/keidarc/kubectl-execrec&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;Kubernetes has built-in audit logs, but they only capture API calls, not the actual session content. When you use &lt;code&gt;kubectl exec&lt;/code&gt;, you get audit entries showing who accessed which pod, but not what commands were run or what output was produced.&lt;/p&gt;&#xA;&lt;p&gt;For comprehensive security monitoring, tools like &lt;a href=&#34;https://falco.org/&#34;&gt;Falco&lt;/a&gt; provide real-time threat detection across containers and Kubernetes. However, these are heavy solutions designed for enterprise security teams.&lt;/p&gt;</description>
    </item>
    <item>
      <title>A Comprehensive Amazon EKS v1.32 Upgrade Log with Terraform and Karpenter</title>
      <link>https://xingyahao.com/posts/comprehensive-amazon-eks-v1-32-upgrade-log-with-terraform-and-karpenter/</link>
      <pubDate>Tue, 29 Apr 2025 09:21:51 +0900</pubDate>
      <guid>https://xingyahao.com/posts/comprehensive-amazon-eks-v1-32-upgrade-log-with-terraform-and-karpenter/</guid>
      <description>&lt;h2 id=&#34;context&#34;&gt;Context&lt;/h2&gt;&#xA;&lt;p&gt;In our organization, we encountered increasing complexity with our applications and realized that we could leverage the benefits of Kubernetes over Amazon ECS. We already had a managed EKS cluster and had deployed some internal tools on Kubernetes, appreciating the platform&amp;rsquo;s convenience. As a result, we decided to migrate all of our running applications to Kubernetes.&lt;/p&gt;&#xA;&lt;p&gt;We are currently in the process of migrating about 100 ECS services to Kubernetes. A portion of our production traffic (around 20%) is already running on Kubernetes, and several internal tools are also being handled by the cluster. Before routing more critical traffic to Kubernetes, I wanted to ensure that the upgrade to EKS v1.32 would cause minimal disruption to our production services.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Introducing kubectl-eks-viewer Bridge the Gap between kubectl and AWS CLI</title>
      <link>https://xingyahao.com/posts/introducing-kubectl-eks-viewer-bridge-the-gap-between-kubectl-and-aws-cli/</link>
      <pubDate>Sat, 01 Feb 2025 09:21:51 +0900</pubDate>
      <guid>https://xingyahao.com/posts/introducing-kubectl-eks-viewer-bridge-the-gap-between-kubectl-and-aws-cli/</guid>
      <description>&lt;p&gt;As a developer working with Amazon EKS (Elastic Kubernetes Service), I often found myself juggling between different tools like &lt;code&gt;eksctl&lt;/code&gt;, &lt;code&gt;aws-cli&lt;/code&gt;, and &lt;code&gt;kubectl&lt;/code&gt; to manage and view EKS resources. While &lt;code&gt;kubectl&lt;/code&gt; provides a great interface for Kubernetes resources, accessing AWS-specific EKS resources required switching to other tools, breaking the workflow and reducing productivity.&lt;/p&gt;&#xA;&lt;p&gt;The most common task was simply checking the status of EKS-related AWS resources - What are the desired count of my nodegroups? What addons are installed? What pod identity associations exist? Getting this information required multiple commands across different tools. I wanted a single command that could show me everything at once, following the familiar kubectl patterns I use every day.&lt;/p&gt;</description>
    </item>
    <item>
      <title>AWS ECSの日常運用とセキュリティの改善ためのE1sの使用</title>
      <link>https://xingyahao.com/posts/integrate-e1s-to-improve-aws-ecs-daily-operations-with-security-ja/</link>
      <pubDate>Tue, 31 Dec 2024 09:21:51 +0900</pubDate>
      <guid>https://xingyahao.com/posts/integrate-e1s-to-improve-aws-ecs-daily-operations-with-security-ja/</guid>
      <description>&lt;h2 id=&#34;はじめに&#34;&gt;はじめに&lt;/h2&gt;&#xA;&lt;p&gt;いまのでは、私がいるSREチームは開発者がORMメソッドを通じてデータベースにアクセスできる機能を提供していました。これには、セキュリティを確保しながら本番環境の最新スキーマを維持する必要のため、本番環境複製して、開発者アクセス用の環境を提供してきました。&lt;/p&gt;&#xA;&lt;p&gt;以前、システムの本番トラフィックは完全にEC2からECSに移行しましたが、データベースアクセスのワークフローはレガシーな移行が完了していなかったため、引き続き専用のEC2インスタンスに依存していました。しかし、このアプローチにはいくつかの課題がありました：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;SSHキーの管理&lt;/strong&gt;：サーバーアクセス用&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;スケーラビリティの制限&lt;/strong&gt;：運用オーバーヘッド&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;複雑なCI/CDパイプライン&lt;/strong&gt;：EC2インスタンスに紐づいている&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;高額なAWSコスト&lt;/strong&gt;：継続的なEC2使用による&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;セキュリティリスク&lt;/strong&gt;：粒度の低いアクセス制御と限られた監査機能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;これらの問題に対処するため、&lt;a href=&#34;https://github.com/keidarcy/e1s&#34;&gt;e1s&lt;/a&gt;（ターミナルでECSリソースを管理するCLIツール）をECS Execと統合し、データベースアクセスのEC2ベースのワークフローを置き換えました。この移行により、運用が簡素化され、コストが削減され、セキュリティが向上しました。&lt;/p&gt;&#xA;&lt;h2 id=&#34;旧ワークフローと新ワークフローの比較&#34;&gt;旧ワークフローと新ワークフローの比較&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;旧ワークフロー：専用EC2インスタンス経由のアクセス&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;チームメンバーは特定のEC2サーバーにSSHキーを使用してログイン&lt;/li&gt;&#xA;&lt;li&gt;運用タスクはこれらのインスタンス上で手動実行&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://storage.googleapis.com/zenn-user-upload/cbe42adfc429-20241231.png&#34; alt=&#34;old-workflow.png&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34;&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;新ワークフロー：e1sを使用したECSベースの運用&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;チームメンバーは、&lt;a href=&#34;https://github.com/onelogin/onelogin-python-aws-assume-role&#34;&gt;onelogin aws assume role cli&lt;/a&gt;（OneLoginは私たちの会社全体で使用しているIDプロバイダー）を使用して、AWSの一時的な認証情報を取得します。&lt;/li&gt;&#xA;&lt;li&gt;セキュリティ上の理由から、本番コンテナのexecは無効にしたままで、運用コンテナに対してECS Execアクセスを有効にします。&lt;/li&gt;&#xA;&lt;li&gt;チームメンバーは、&lt;a href=&#34;https://github.com/keidarcy/e1s&#34;&gt;e1s&lt;/a&gt;を使用し、特定のAWS認証情報でECS Execを簡単に実行して、監査ログが完全に記録された状態でコンテナを操作します。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://storage.googleapis.com/zenn-user-upload/c733932fd992-20241231.png&#34; alt=&#34;new-workflow.png&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34;&gt;&#xA;&lt;/p&gt;&#xA;&lt;h2 id=&#34;メリット概要&#34;&gt;メリット概要&lt;/h2&gt;&#xA;&lt;h3 id=&#34;複雑さの軽減&#34;&gt;&lt;strong&gt;複雑さの軽減&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SSHキーと専用EC2サーバーの必要性を排除し、キー管理に関連する手動運用を削減&lt;/li&gt;&#xA;&lt;li&gt;EC2デプロイメント要件を削除することでCIワークフローを簡素化&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;セキュリティの強化&#34;&gt;&lt;strong&gt;セキュリティの強化&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SSHキーの管理が不要となり、忘れたり紛失したりするリスクを排除&lt;/li&gt;&#xA;&lt;li&gt;本番環境のシークレットを特定のECSコンテナに分離&lt;/li&gt;&#xA;&lt;li&gt;OneLogin付与のIAMロールを通じてロールベースのアクセス制御（RBAC）を強制&lt;/li&gt;&#xA;&lt;li&gt;ECS Execの出力をS3にログ記録し、監査とトレーサビリティを向上&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;コスト効率&#34;&gt;&lt;strong&gt;コスト効率&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;継続的なEC2インスタンスを削除することでAWS費用を大幅に削減&lt;/li&gt;&#xA;&lt;li&gt;EC2固有のデプロイメントパイプラインを排除することでCIコストを削減&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;結論&#34;&gt;結論&lt;/h2&gt;&#xA;&lt;p&gt;現代のテックチームにとって、インフラストラクチャのセキュリティと運用効率の管理は重要です。&lt;a href=&#34;https://github.com/keidarcy/e1s&#34;&gt;e1s&lt;/a&gt;への移行により、私たちの運用はよりスリムで、より安全で、よりコスト効率の良いワークフローへと改善されました。&lt;a href=&#34;https://github.com/keidarcy/e1s&#34;&gt;e1s&lt;/a&gt;が皆様のツールキットの一部となり、私たちと同様に運用を簡素化することを願っています！&lt;/p&gt;</description>
    </item>
    <item>
      <title>Integrate E1s to Improve AWS ECS Daily Operations with Security</title>
      <link>https://xingyahao.com/posts/integrate-e1s-to-improve-aws-ecs-daily-operations-with-security/</link>
      <pubDate>Tue, 31 Dec 2024 09:21:51 +0900</pubDate>
      <guid>https://xingyahao.com/posts/integrate-e1s-to-improve-aws-ecs-daily-operations-with-security/</guid>
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;p&gt;In my organization, we maintained a feature that allows developers to access databases via ORM methods. This required duplicating the environment to provide a separate environment for developer access, ensuring security while maintaining an up-to-date deployment with the latest schema for production.&lt;/p&gt;&#xA;&lt;p&gt;Previously, we had fully migrated the system production traffic from EC2 to ECS, but the database access workflow continued to rely on dedicated EC2 instances due to the incomplete legacy migration. However, this approach introduced several challenges:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Migrating Next.js Landing Page Projects from Vercel to AWS</title>
      <link>https://xingyahao.com/posts/migrating-next-js-landing-page-projects-from-vercel-to-aws/</link>
      <pubDate>Mon, 30 Dec 2024 11:46:46 +0900</pubDate>
      <guid>https://xingyahao.com/posts/migrating-next-js-landing-page-projects-from-vercel-to-aws/</guid>
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;p&gt;My team manages multiple landing page projects, including around 100,000 pages. Vercel initially served us well, especially with its preview URL feature for rapid feedback and built-in Next.js support to start development quickly. However, many of you may have seen this famous tweet about the surprising Vercel cost.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://storage.googleapis.com/zenn-user-upload/f33169715eb4-20241231.png&#34; alt=&#34;Screenshot 2024-12-30 at 14.40.48.png&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34;&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;My team experienced a similar moment: our monthly costs jumped from ~$2,000 to ~$3,500 due to a single server error happening in one day. This led us to migrate to AWS ECS, a decision that significantly &lt;strong&gt;improved performance and cost efficiency.&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Introducing E1s the K9s Inspired Cli for Aws Ecs</title>
      <link>https://xingyahao.com/posts/introducing-e1s-the-k9s-inspired-cli-for-aws-ecs/</link>
      <pubDate>Fri, 19 Apr 2024 09:21:51 +0900</pubDate>
      <guid>https://xingyahao.com/posts/introducing-e1s-the-k9s-inspired-cli-for-aws-ecs/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://storage.googleapis.com/zenn-user-upload/84798ff12916-20240531.png&#34; alt=&#34;84798ff12916 20240531&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34;&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;If you&amp;rsquo;re working with AWS ECS like me, no matter whether with Fargate or EC2, managing resources can sometimes be a challenge to using aws-cli. You might look for something that brings the ease of k9s to k8s, thee1s aims to become the tool you&amp;rsquo;ve been waiting for.&#xA;If you&amp;rsquo;re working with AWS ECS, managing resources with aws-cli can sometimes be a challenge, whether you&amp;rsquo;re using Fargate or EC2. For those seeking the ease of k9s for Kubernetes, e1s is the tool you&amp;rsquo;ve been waiting for.&lt;/p&gt;</description>
    </item>
    <item>
      <title>How Do We Optimize Mongodb Latency and Save Money</title>
      <link>https://xingyahao.com/posts/how-do-we-optimize-mongodb-latency-and-save-money/</link>
      <pubDate>Thu, 04 Jan 2024 22:21:06 +0900</pubDate>
      <guid>https://xingyahao.com/posts/how-do-we-optimize-mongodb-latency-and-save-money/</guid>
      <description>&lt;h2 id=&#34;context&#34;&gt;Context&lt;/h2&gt;&#xA;&lt;p&gt;My organization has used MongoDB on MongoDB Atlas for over 6 years. Our backend API language is TypeScript, and we use Mongoose as our ORM. While we appreciate our tech stack&amp;rsquo;s productivity, we also find it challenging to improve server endpoint latency and balance cloud costs.&lt;/p&gt;&#xA;&lt;p&gt;As our active users and product grew this year, we noticed a significant regression in endpoint response time. This indicated a major issue with MongoDB’s performance. As a temporary solution, we scaled up the production cluster tiers, resulting in a 40% increase in our billing. The following graphs are the average MongoDB read latency and monthly billing shift before the project. As you can see we were facing a critical period.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
